open Ast_helper
(* # #show_module Ast_helper;; *)
(* module Ast_helper : *)
(*   sig *)
(*     type 'a with_loc = 'a Location.loc *)
(*     type loc = Location.t *)
(*     type lid = Longident.t with_loc *)
(*     type str = string with_loc *)
(*     type str_opt = string option with_loc *)
(*     type attrs = Parsetree.attribute list *)
(*     val default_loc : loc ref *)
(*     val with_default_loc : loc -> (unit -> 'a) -> 'a *)
(*     module Const : sig ... end *)
(*     module Attr : sig ... end *)
(*     module Typ : sig ... end *)
(*     module Pat : sig ... end *)
(*     module Exp : sig ... end *)
(*     module Val : sig ... end *)
(*     module Type : sig ... end *)
(*     module Te : sig ... end *)
(*     module Mty : sig ... end *)
(*     module Mod : sig ... end *)
(*     module Sig : sig ... end *)
(*     module Str : sig ... end *)
(*     module Md : sig ... end *)
(*     module Ms : sig ... end *)
(*     module Mtd : sig ... end *)
(*     module Mb : sig ... end *)
(*     module Opn : sig ... end *)
(*     module Incl : sig ... end *)
(*     module Vb : sig ... end *)
(*     module Cty : sig ... end *)
(*     module Ctf : sig ... end *)
(*     module Cl : sig ... end *)
(*     module Cf : sig ... end *)
(*     module Ci : sig ... end *)
(*     module Csig : sig ... end *)
(*     module Cstr : sig ... end *)
(*     module Rf : sig ... end *)
(*     module Of : sig ... end *)
(*   end *)
(* #  *)
open Ast_invariants	
open Ast_iterator	
open Ast_mapper	
open Asttypes	
open Attr_helper	
open Builtin_attributes	
open CamlinternalMenhirLib	
open Depend	
open Docstrings	
open Lexer	
open Location
(* # #show Location;; *)
(* module Location : *)
(*   sig *)
(*     type t = *)
(*       Warnings.loc = { *)
(*       loc_start : Lexing.position; *)
(*       loc_end : Lexing.position; *)
(*       loc_ghost : bool; *)
(*     } *)
(*     val none : t *)
(*     val is_none : t -> bool *)
(*     val in_file : string -> t *)
(*     val init : Lexing.lexbuf -> string -> unit *)
(*     val curr : Lexing.lexbuf -> t *)
(*     val symbol_rloc : unit -> t *)
(*     val symbol_gloc : unit -> t *)
(*     val rhs_loc : int -> t *)
(*     val rhs_interval : int -> int -> t *)
(*     val get_pos_info : Lexing.position -> string * int * int *)
(*     type 'a loc = { txt : 'a; loc : t; } *)
(*     val mknoloc : 'a -> 'a loc *)
(*     val mkloc : 'a -> t -> 'a loc *)
(*     val input_name : string ref *)
(*     val input_lexbuf : Lexing.lexbuf option ref *)
(*     val input_phrase_buffer : Buffer.t option ref *)
(*     val echo_eof : unit -> unit *)
(*     val reset : unit -> unit *)
(*     val rewrite_absolute_path : string -> string *)
(*     val absolute_path : string -> string *)
(*     val show_filename : string -> string *)
(*     val print_filename : Format.formatter -> string -> unit *)
(*     val print_loc : Format.formatter -> t -> unit *)
(*     val print_locs : Format.formatter -> t list -> unit *)
(*     val highlight_terminfo : *)
(*       Lexing.lexbuf -> Format.formatter -> t list -> unit *)
(*     type msg = (Format.formatter -> unit) loc *)
(*     val msg : ?loc:t -> ('a, Format.formatter, unit, msg) format4 -> 'a *)
(*     type report_kind = *)
(*         Report_error *)
(*       | Report_warning of string *)
(*       | Report_warning_as_error of string *)
(*       | Report_alert of string *)
(*       | Report_alert_as_error of string *)
(*     type report = { kind : report_kind; main : msg; sub : msg list; } *)
(*     type report_printer = { *)
(*       pp : report_printer -> Format.formatter -> report -> unit; *)
(*       pp_report_kind : *)
(*         report_printer -> report -> Format.formatter -> report_kind -> unit; *)
(*       pp_main_loc : report_printer -> report -> Format.formatter -> t -> unit; *)
(*       pp_main_txt : *)
(*         report_printer -> *)
(*         report -> Format.formatter -> (Format.formatter -> unit) -> unit; *)
(*       pp_submsgs : *)
(*         report_printer -> report -> Format.formatter -> msg list -> unit; *)
(*       pp_submsg : report_printer -> report -> Format.formatter -> msg -> unit; *)
(*       pp_submsg_loc : *)
(*         report_printer -> report -> Format.formatter -> t -> unit; *)
(*       pp_submsg_txt : *)
(*         report_printer -> *)
(*         report -> Format.formatter -> (Format.formatter -> unit) -> unit; *)
(*     } *)
(*     val batch_mode_printer : report_printer *)
(*     val terminfo_toplevel_printer : Lexing.lexbuf -> report_printer *)
(*     val best_toplevel_printer : unit -> report_printer *)
(*     val print_report : Format.formatter -> report -> unit *)
(*     val report_printer : (unit -> report_printer) ref *)
(*     val default_report_printer : unit -> report_printer *)
(*     val report_warning : t -> Warnings.t -> report option *)
(*     val warning_reporter : (t -> Warnings.t -> report option) ref *)
(*     val default_warning_reporter : t -> Warnings.t -> report option *)
(*     val formatter_for_warnings : Format.formatter ref *)
(*     val print_warning : t -> Format.formatter -> Warnings.t -> unit *)
(*     val prerr_warning : t -> Warnings.t -> unit *)
(*     val report_alert : t -> Warnings.alert -> report option *)
(*     val alert_reporter : (t -> Warnings.alert -> report option) ref *)
(*     val default_alert_reporter : t -> Warnings.alert -> report option *)
(*     val print_alert : t -> Format.formatter -> Warnings.alert -> unit *)
(*     val prerr_alert : t -> Warnings.alert -> unit *)
(*     val deprecated : ?def:t -> ?use:t -> t -> string -> unit *)
(*     val alert : ?def:t -> ?use:t -> kind:string -> t -> string -> unit *)
(*     type error = report *)
(*     val error : ?loc:t -> ?sub:msg list -> string -> error *)
(*     val errorf : *)
(*       ?loc:t -> *)
(*       ?sub:msg list -> ('a, Format.formatter, unit, error) format4 -> 'a *)
(*     val error_of_printer : *)
(*       ?loc:t -> *)
(*       ?sub:msg list -> (Format.formatter -> 'a -> unit) -> 'a -> error *)
(*     val error_of_printer_file : *)
(*       (Format.formatter -> 'a -> unit) -> 'a -> error *)
(*     val register_error_of_exn : (exn -> error option) -> unit *)
(*     val error_of_exn : exn -> [ `Already_displayed | `Ok of error ] option *)
(*     exception Error of error *)
(*     exception Already_displayed_error *)
(*     val raise_errorf : *)
(*       ?loc:t -> *)
(*       ?sub:msg list -> ('a, Format.formatter, unit, 'b) format4 -> 'a *)
(*     val report_exception : Format.formatter -> exn -> unit *)
(*   end *)
(* #  *)
open Longident	
open Parse	
open Parser	
open Parsetree	
open Pprintast	
open Printast	
open Syntaxerr	
(* open Unit_info	*)
open Arg_helper	
open Binutils	
open Build_path_prefix_map	
open Ccomp	
open Clflags	
(* open Compression	 *)
(* open Config_boot	 *)
(* open Config_main	 *)
open Config	
open Consistbl	
open Diffing	
open Diffing_with_keys	
open Domainstate	
open Identifiable	
open Int_replace_polymorphic_compare	
open Lazy_backtrack	
open Load_path	
open Local_store	
open Misc	
open Numbers	
open Profile	
open Strongly_connected_components	
open Targetint	
open Terminfo

open Warnings	
open Pparse	

module type AstSig = module type of Ast_helper
 [@@deriving show]

module type PparseSig = module type of Pparse
module ShowMyModuleSig : AstSig = Ast_helper
module Show1 : PparseSig = Pparse


(* # #show Env;; *)
(* module Env : *)
(*   sig *)
(*     val register_uid : Types.Uid.t -> Location.t -> unit *)
(*     val get_uid_to_loc_tbl : unit -> Location.t Types.Uid.Tbl.t *)
(*     type value_unbound_reason = *)
(*         Val_unbound_instance_variable *)
(*       | Val_unbound_self *)
(*       | Val_unbound_ancestor *)
(*       | Val_unbound_ghost_recursive of Location.t *)
(*     type module_unbound_reason = Mod_unbound_illegal_recursion *)
(*     type summary = *)
(*         Env_empty *)
(*       | Env_value of summary * Ident.t * Types.value_description *)
(*       | Env_type of summary * Ident.t * Types.type_declaration *)
(*       | Env_extension of summary * Ident.t * Types.extension_constructor *)
(*       | Env_module of summary * Ident.t * Types.module_presence * *)
(*           Types.module_declaration *)
(*       | Env_modtype of summary * Ident.t * Types.modtype_declaration *)
(*       | Env_class of summary * Ident.t * Types.class_declaration *)
(*       | Env_cltype of summary * Ident.t * Types.class_type_declaration *)
(*       | Env_open of summary * Path.t *)
(*       | Env_functor_arg of summary * Ident.t *)
(*       | Env_constraints of summary * Types.type_declaration Path.Map.t *)
(*       | Env_copy_types of summary *)
(*       | Env_persistent of summary * Ident.t *)
(*       | Env_value_unbound of summary * string * value_unbound_reason *)
(*       | Env_module_unbound of summary * string * module_unbound_reason *)
(*     type address = Aident of Ident.t | Adot of address * int *)
(*     type t *)
(*     val empty : t *)
(*     val initial_safe_string : t *)
(*     val initial_unsafe_string : t *)
(*     val diff : t -> t -> Ident.t list *)
(*     type type_descr_kind = *)
(*         (Types.label_description, Types.constructor_description) *)
(*         Types.type_kind *)
(*     type type_descriptions = type_descr_kind *)
(*     type iter_cont *)
(*     val iter_types : *)
(*       (Path.t -> Path.t * Types.type_declaration -> unit) -> t -> iter_cont *)
(*     val run_iter_cont : iter_cont list -> (Path.t * iter_cont) list *)
(*     val same_types : t -> t -> bool *)
(*     val used_persistent : unit -> Misc.Stdlib.String.Set.t *)
(*     val find_shadowed_types : Path.t -> t -> Path.t list *)
(*     val without_cmis : ('a -> 'b) -> 'a -> 'b *)
(*     val find_value : Path.t -> t -> Types.value_description *)
(*     val find_type : Path.t -> t -> Types.type_declaration *)
(*     val find_type_descrs : Path.t -> t -> type_descriptions *)
(*     val find_module : Path.t -> t -> Types.module_declaration *)
(*     val find_modtype : Path.t -> t -> Types.modtype_declaration *)
(*     val find_class : Path.t -> t -> Types.class_declaration *)
(*     val find_cltype : Path.t -> t -> Types.class_type_declaration *)
(*     val find_strengthened_module : *)
(*       aliasable:bool -> Path.t -> t -> Types.module_type *)
(*     val find_ident_constructor : *)
(*       Ident.t -> t -> Types.constructor_description *)
(*     val find_ident_label : Ident.t -> t -> Types.label_description *)
(*     val find_type_expansion : *)
(*       Path.t -> t -> Types.type_expr list * Types.type_expr * int *)
(*     val find_type_expansion_opt : *)
(*       Path.t -> t -> Types.type_expr list * Types.type_expr * int *)
(*     val find_modtype_expansion : Path.t -> t -> Types.module_type *)
(*     val find_modtype_expansion_lazy : Path.t -> t -> Subst.Lazy.modtype *)
(*     val find_hash_type : Path.t -> t -> Types.type_declaration *)
(*     val find_value_address : Path.t -> t -> address *)
(*     val find_module_address : Path.t -> t -> address *)
(*     val find_class_address : Path.t -> t -> address *)
(*     val find_constructor_address : Path.t -> t -> address *)
(*     val shape_of_path : *)
(*       namespace:Shape.Sig_component_kind.t -> t -> Path.t -> Shape.t *)
(*     val add_functor_arg : Ident.t -> t -> t *)
(*     val is_functor_arg : Path.t -> t -> bool *)
(*     val normalize_module_path : Location.t option -> t -> Path.t -> Path.t *)
(*     val normalize_type_path : Location.t option -> t -> Path.t -> Path.t *)
(*     val normalize_path_prefix : Location.t option -> t -> Path.t -> Path.t *)
(*     val normalize_modtype_path : t -> Path.t -> Path.t *)
(*     val reset_required_globals : unit -> unit *)
(*     val get_required_globals : unit -> Ident.t list *)
(*     val add_required_global : Ident.t -> unit *)
(*     val has_local_constraints : t -> bool *)
(*     val mark_value_used : Types.Uid.t -> unit *)
(*     val mark_module_used : Types.Uid.t -> unit *)
(*     val mark_type_used : Types.Uid.t -> unit *)
(*     type constructor_usage = Positive | Pattern | Exported_private | Exported *)
(*     val mark_constructor_used : *)
(*       constructor_usage -> Types.constructor_declaration -> unit *)
(*     val mark_extension_used : *)
(*       constructor_usage -> Types.extension_constructor -> unit *)
(*     type label_usage = *)
(*         Projection *)
(*       | Mutation *)
(*       | Construct *)
(*       | Exported_private *)
(*       | Exported *)
(*     val mark_label_used : label_usage -> Types.label_declaration -> unit *)
(*     type unbound_value_hint = No_hint | Missing_rec of Location.t *)
(*     type lookup_error = *)
(*         Unbound_value of Longident.t * unbound_value_hint *)
(*       | Unbound_type of Longident.t *)
(*       | Unbound_constructor of Longident.t *)
(*       | Unbound_label of Longident.t *)
(*       | Unbound_module of Longident.t *)
(*       | Unbound_class of Longident.t *)
(*       | Unbound_modtype of Longident.t *)
(*       | Unbound_cltype of Longident.t *)
(*       | Unbound_instance_variable of string *)
(*       | Not_an_instance_variable of string *)
(*       | Masked_instance_variable of Longident.t *)
(*       | Masked_self_variable of Longident.t *)
(*       | Masked_ancestor_variable of Longident.t *)
(*       | Structure_used_as_functor of Longident.t *)
(*       | Abstract_used_as_functor of Longident.t *)
(*       | Functor_used_as_structure of Longident.t *)
(*       | Abstract_used_as_structure of Longident.t *)
(*       | Generative_used_as_applicative of Longident.t *)
(*       | Illegal_reference_to_recursive_module *)
(*       | Cannot_scrape_alias of Longident.t * Path.t *)
(*     val lookup_error : Location.t -> t -> lookup_error -> 'a *)
(*     val lookup_value : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> Longident.t -> t -> Path.t * Types.value_description *)
(*     val lookup_type : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> Longident.t -> t -> Path.t * Types.type_declaration *)
(*     val lookup_module : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> Longident.t -> t -> Path.t * Types.module_declaration *)
(*     val lookup_modtype : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> *)
(*       Longident.t -> t -> Path.t * Types.modtype_declaration *)
(*     val lookup_class : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> Longident.t -> t -> Path.t * Types.class_declaration *)
(*     val lookup_cltype : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> *)
(*       Longident.t -> t -> Path.t * Types.class_type_declaration *)
(*     val lookup_module_path : *)
(*       ?use:bool -> loc:Location.t -> load:bool -> Longident.t -> t -> Path.t *)
(*     val lookup_modtype_path : *)
(*       ?use:bool -> loc:Location.t -> Longident.t -> t -> Path.t *)
(*     val lookup_constructor : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> *)
(*       constructor_usage -> Longident.t -> t -> Types.constructor_description *)
(*     val lookup_all_constructors : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> *)
(*       constructor_usage -> *)
(*       Longident.t -> *)
(*       t -> *)
(*       ((Types.constructor_description * (unit -> unit)) list, *)
(*        Location.t * t * lookup_error) *)
(*       result *)
(*     val lookup_all_constructors_from_type : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> *)
(*       constructor_usage -> *)
(*       Path.t -> t -> (Types.constructor_description * (unit -> unit)) list *)
(*     val lookup_label : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> *)
(*       label_usage -> Longident.t -> t -> Types.label_description *)
(*     val lookup_all_labels : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> *)
(*       label_usage -> *)
(*       Longident.t -> *)
(*       t -> *)
(*       ((Types.label_description * (unit -> unit)) list, *)
(*        Location.t * t * lookup_error) *)
(*       result *)
(*     val lookup_all_labels_from_type : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> *)
(*       label_usage -> *)
(*       Path.t -> t -> (Types.label_description * (unit -> unit)) list *)
(*     val lookup_instance_variable : *)
(*       ?use:bool -> *)
(*       loc:Location.t -> *)
(*       string -> *)
(*       t -> Path.t * Asttypes.mutable_flag * string * Types.type_expr *)
(*     val find_value_by_name : *)
(*       Longident.t -> t -> Path.t * Types.value_description *)
(*     val find_type_by_name : *)
(*       Longident.t -> t -> Path.t * Types.type_declaration *)
(*     val find_module_by_name : *)
(*       Longident.t -> t -> Path.t * Types.module_declaration *)
(*     val find_modtype_by_name : *)
(*       Longident.t -> t -> Path.t * Types.modtype_declaration *)
(*     val find_class_by_name : *)
(*       Longident.t -> t -> Path.t * Types.class_declaration *)
(*     val find_cltype_by_name : *)
(*       Longident.t -> t -> Path.t * Types.class_type_declaration *)
(*     val find_constructor_by_name : *)
(*       Longident.t -> t -> Types.constructor_description *)
(*     val find_label_by_name : Longident.t -> t -> Types.label_description *)
(*     val bound_value : string -> t -> bool *)
(*     val bound_module : string -> t -> bool *)
(*     val bound_type : string -> t -> bool *)
(*     val bound_modtype : string -> t -> bool *)
(*     val bound_class : string -> t -> bool *)
(*     val bound_cltype : string -> t -> bool *)
(*     val make_copy_of_types : t -> t -> t *)
(*     val add_value : *)
(*       ?check:(string -> Warnings.t) -> *)
(*       Ident.t -> Types.value_description -> t -> t *)
(*     val add_type : check:bool -> Ident.t -> Types.type_declaration -> t -> t *)
(*     val add_extension : *)
(*       check:bool -> *)
(*       rebind:bool -> Ident.t -> Types.extension_constructor -> t -> t *)
(*     val add_module : *)
(*       ?arg:bool -> *)
(*       ?shape:Shape.t -> *)
(*       Ident.t -> Types.module_presence -> Types.module_type -> t -> t *)
(*     val add_module_declaration : *)
(*       ?arg:bool -> *)
(*       ?shape:Shape.t -> *)
(*       check:bool -> *)
(*       Ident.t -> Types.module_presence -> Types.module_declaration -> t -> t *)
(*     val add_module_declaration_lazy : *)
(*       update_summary:bool -> *)
(*       Ident.t -> Types.module_presence -> Subst.Lazy.module_decl -> t -> t *)
(*     val add_modtype : Ident.t -> Types.modtype_declaration -> t -> t *)
(*     val add_modtype_lazy : *)
(*       update_summary:bool -> *)
(*       Ident.t -> Subst.Lazy.modtype_declaration -> t -> t *)
(*     val add_class : Ident.t -> Types.class_declaration -> t -> t *)
(*     val add_cltype : Ident.t -> Types.class_type_declaration -> t -> t *)
(*     val add_local_type : Path.t -> Types.type_declaration -> t -> t *)
(*     val add_persistent_structure : Ident.t -> t -> t *)
(*     val persistent_structures_of_dir : *)
(*       Load_path.Dir.t -> Misc.Stdlib.String.Set.t *)
(*     val filter_non_loaded_persistent : (Ident.t -> bool) -> t -> t *)
(*     val add_signature : Types.signature -> t -> t *)
(*     val open_signature : *)
(*       ?used_slot:bool ref -> *)
(*       ?loc:Location.t -> *)
(*       ?toplevel:bool -> *)
(*       Asttypes.override_flag -> *)
(*       Path.t -> t -> (t, [ `Functor | `Not_found ]) result *)
(*     val open_pers_signature : string -> t -> (t, [ `Not_found ]) result *)
(*     val remove_last_open : Path.t -> t -> t option *)
(*     val enter_value : *)
(*       ?check:(string -> Warnings.t) -> *)
(*       string -> Types.value_description -> t -> Ident.t * t *)
(*     val enter_type : *)
(*       scope:int -> string -> Types.type_declaration -> t -> Ident.t * t *)
(*     val enter_extension : *)
(*       scope:int -> *)
(*       rebind:bool -> *)
(*       string -> Types.extension_constructor -> t -> Ident.t * t *)
(*     val enter_module : *)
(*       scope:int -> *)
(*       ?arg:bool -> *)
(*       string -> *)
(*       Types.module_presence -> Types.module_type -> t -> Ident.t * t *)
(*     val enter_module_declaration : *)
(*       scope:int -> *)
(*       ?arg:bool -> *)
(*       ?shape:Shape.t -> *)
(*       string -> *)
(*       Types.module_presence -> Types.module_declaration -> t -> Ident.t * t *)
(*     val enter_modtype : *)
(*       scope:int -> string -> Types.modtype_declaration -> t -> Ident.t * t *)
(*     val enter_class : *)
(*       scope:int -> string -> Types.class_declaration -> t -> Ident.t * t *)
(*     val enter_cltype : *)
(*       scope:int -> string -> Types.class_type_declaration -> t -> Ident.t * t *)
(*     val enter_signature : *)
(*       ?mod_shape:Shape.t -> *)
(*       scope:int -> Types.signature -> t -> Types.signature * t *)
(*     val enter_signature_and_shape : *)
(*       scope:int -> *)
(*       parent_shape:Shape.Map.t -> *)
(*       Shape.t -> Types.signature -> t -> Types.signature * Shape.Map.t * t *)
(*     val enter_unbound_value : string -> value_unbound_reason -> t -> t *)
(*     val enter_unbound_module : string -> module_unbound_reason -> t -> t *)
(*     val reset_cache : unit -> unit *)
(*     val reset_cache_toplevel : unit -> unit *)
(*     val set_unit_name : string -> unit *)
(*     val get_unit_name : unit -> string *)
(*     val read_signature : Misc.modname -> Misc.filepath -> Types.signature *)
(*     val save_signature : *)
(*       alerts:Misc.alerts -> *)
(*       Types.signature -> *)
(*       Misc.modname -> Misc.filepath -> Cmi_format.cmi_infos *)
(*     val save_signature_with_imports : *)
(*       alerts:Misc.alerts -> *)
(*       Types.signature -> *)
(*       Misc.modname -> Misc.filepath -> Misc.crcs -> Cmi_format.cmi_infos *)
(*     val crc_of_unit : Misc.modname -> Digest.t *)
(*     val imports : unit -> Misc.crcs *)
(*     val import_crcs : source:string -> Misc.crcs -> unit *)
(*     val is_imported_opaque : Misc.modname -> bool *)
(*     val register_import_as_opaque : Misc.modname -> unit *)
(*     val summary : t -> summary *)
(*     val keep_only_summary : t -> t *)
(*     val env_of_only_summary : (summary -> Subst.t -> t) -> t -> t *)
(*     type error = *)
(*         Missing_module of Location.t * Path.t * Path.t *)
(*       | Illegal_value_name of Location.t * string *)
(*       | Lookup_error of Location.t * t * lookup_error *)
(*     exception Error of error *)
(*     val report_error : Format.formatter -> error -> unit *)
(*     val report_lookup_error : *)
(*       Location.t -> t -> Format.formatter -> lookup_error -> unit *)
(*     val in_signature : bool -> t -> t *)
(*     val is_in_signature : t -> bool *)
(*     val set_value_used_callback : *)
(*       Types.value_description -> (unit -> unit) -> unit *)
(*     val set_type_used_callback : *)
(*       Types.type_declaration -> ((unit -> unit) -> unit) -> unit *)
(*     val check_functor_application : *)
(*       (errors:bool -> *)
(*        loc:Location.t -> *)
(*        lid_whole_app:Longident.t -> *)
(*        f0_path:Path.t -> *)
(*        args:(Path.t * Types.module_type) list -> *)
(*        arg_path:Path.t -> *)
(*        arg_mty:Types.module_type -> param_mty:Types.module_type -> t -> unit) *)
(*       ref *)
(*     val check_well_formed_module : *)
(*       (t -> Location.t -> string -> Types.module_type -> unit) ref *)
(*     val add_delayed_check_forward : ((unit -> unit) -> unit) ref *)
(*     val strengthen : *)
(*       (aliasable:bool -> *)
(*        t -> Subst.Lazy.modtype -> Path.t -> Subst.Lazy.modtype) *)
(*       ref *)
(*     val same_constr : (t -> Types.type_expr -> Types.type_expr -> bool) ref *)
(*     val print_longident : (Format.formatter -> Longident.t -> unit) ref *)
(*     val print_path : (Format.formatter -> Path.t -> unit) ref *)
(*     val fold_values : *)
(*       (string -> Path.t -> Types.value_description -> 'a -> 'a) -> *)
(*       Longident.t option -> t -> 'a -> 'a *)
(*     val fold_types : *)
(*       (string -> Path.t -> Types.type_declaration -> 'a -> 'a) -> *)
(*       Longident.t option -> t -> 'a -> 'a *)
(*     val fold_constructors : *)
(*       (Types.constructor_description -> 'a -> 'a) -> *)
(*       Longident.t option -> t -> 'a -> 'a *)
(*     val fold_labels : *)
(*       (Types.label_description -> 'a -> 'a) -> *)
(*       Longident.t option -> t -> 'a -> 'a *)
(*     val fold_modules : *)
(*       (string -> Path.t -> Types.module_declaration -> 'a -> 'a) -> *)
(*       Longident.t option -> t -> 'a -> 'a *)
(*     val fold_modtypes : *)
(*       (string -> Path.t -> Types.modtype_declaration -> 'a -> 'a) -> *)
(*       Longident.t option -> t -> 'a -> 'a *)
(*     val fold_classes : *)
(*       (string -> Path.t -> Types.class_declaration -> 'a -> 'a) -> *)
(*       Longident.t option -> t -> 'a -> 'a *)
(*     val fold_cltypes : *)
(*       (string -> Path.t -> Types.class_type_declaration -> 'a -> 'a) -> *)
(*       Longident.t option -> t -> 'a -> 'a *)
(*     val scrape_alias : t -> Types.module_type -> Types.module_type *)
(*     val check_value_name : string -> Location.t -> unit *)
(*     val print_address : Format.formatter -> address -> unit *)
(*   end *)
                             (* #  *)


(* #show Types.module_declaration;; *)
	 
(* type module_declaration = { *)
(*   md_type : Types.module_type; *)
(*   md_attributes : Parsetree.attributes; *)
(*   md_loc : Location.t; *)
(*   md_uid : Types.Uid.t; *)
(* } *)
(* #  *)

(* #show Env.find_module_by_name;; *)
	 
(* val find_module_by_name : *)
(*   Longident.t -> Env.t -> Path.t * Types.module_declaration *)
(* #  *)
