* status

** libs

run ppx introspector on these modules

*** menhir
*** gbnf parser
*** ppxlib
*** ocaml_ocaml_types - types.ml extracted from ocaml into standalone module

make sure it works and covers all the cases, 

** unimath
later the target will be to unite unimath with the other modules.

* capture the log

#+begin_src shell
dune build > log.txt 2>&1she
#+end_src

* new try

  (print_endline ("DEBUG2AA:" ^ "open Ppxlib"));
  
grep ^DEBUG2AA: log.txt |cut -d: -f2- |sort -u   > src/gen2.ml

that starts the header

grep ^DEBUG2A: log.txt |cut -d: -f2- |sort -u    >> src/gen2.ml

now for this one we need to remove sort
grep ^DEBUG2B: log.txt |cut -d: -f2-     >> src/gen2.ml


* cleanup scripts.
in test.sh is a horrible monster we found in the sed dungeon.
this removes some known errors.

the next big fix will be to move the case statements inside the proper functions
"DEBUG2C: let process_"
in this function.
process_type_variant_constructor_declaration_list(a:string*constructor_declaration list*string_list):string =

the ordering of the subobject the constructors are wrong.


*
#+begin_src shell
grep DEBUG2E:constructor_declaration_new log.txt |cut "-d|" -f1 | cut -d: -f4- |sort |uniq -c| sort -r
#+end_src

#+RESULTS:
| 1 | "Virtual"{        |
| 1 | "Upto"{           |
| 1 | "Unit"{           |
| 1 | "Rtag"{           |
| 1 | "Pwith_type"{     |
| 1 | "Ptype_abstract"{ |
| 1 | "Ptyp_any"{       |
| 1 | "Ptop_def"{       |
| 1 | "Pstr_eval"{      |
| 1 | "PStr"{           |
| 1 | "Psig_value"{     |
| 1 | "Private"{        |
| 1 | "Ppat_any"{       |
| 1 | "Pmty_ident"{     |
| 1 | "Pmod_ident"{     |
| 1 | "Pext_decl"{      |
| 1 | "Pexp_ident"{     |
| 1 | "Pdir_string"{    |
| 1 | "Pcty_constr"{    |
| 1 | "Pctf_inherit"{   |
| 1 | "Pcstr_tuple"{    |
| 1 | "Pconst_integer"{ |
| 1 | "Pcl_constr"{     |
| 1 | "Pcf_inherit"{    |
| 1 | "Override"{       |
| 1 | "Otag"{           |
| 1 | "O"{              |
| 1 | "Nonrecursive"{   |
| 1 | "Nolabel"{        |
| 1 | "Lident"{         |
| 1 | "Injective"{      |
| 1 | "Immutable"{      |
| 1 | "Covariant"{      |
| 1 | "Coq_tt"{         |
| 1 | "Coq_true"{       |
| 1 | "Coq_paths_refl"{ |
| 1 | "Coq_ii1"{        |
| 1 | "Closed"{         |
| 1 | "Cfk_virtual"{    |

#+begin_src output
The code declares various types related to a graph structure. Here's a creative reinterpretation while preserving the main ideas:

Imagine an artist painting a beautiful landscape on a large canvas. The canvas is divided into smaller squares, each representing a different part of the scene. Each square can contain multiple colors and shapes, which represent the objects in the landscape. The connections between these squares are drawn with lines, representing the relationships between the objects.

The `type` keyword in Coq is used to define new types, just as the artist creates new shapes and colors on their canvas. In this case, we're defining several types related to a graph structure:

* `coq_UU`: This type represents a unique identifier for each object (or square) in the landscape.
* `node`: This type represents a single object (or square) in the landscape. Each object can have multiple colors and shapes, represented by other types.
* `arc`: This type represents a connection between two objects (or squares). The connection can be drawn with lines of different shapes and thicknesses.
* `'x isofhlevel`: This type represents a hierarchy of objects in the landscape, with each level having a unique identifier (`coq_UU`). The higher the level, the more abstract or general the object becomes.
* `(t, p) total2`: This type represents a tuple containing two elements of types `t` and `p`. It is used to represent the connections between objects in the landscape, where each connection can have two different shapes and colors (`t` and `p`).
* `dirprod`: This type represents a directed product of two tuples, which means that the order of the elements matters. In this case, it is used to represent the connections between objects with two different shapes and colors.
* `precgraph`: This type represents a graph structure where each object (or square) has a unique identifier (`coq_UU`) and can be connected to other objects with lines of different shapes and thicknesses. The hierarchy of objects is represented by the `isofhlevel` type.
* `'x isaprop`: This type represents an object (or square) that belongs to a specific level in the hierarchy (`isofhlevel`).
* `'a paths`: This type represents all possible paths between two objects (or squares) in the graph structure, including direct and indirect connections. The paths can have different shapes and thicknesses, represented by other types.
* `coq_paths_refl`: This type represents a single path that starts and ends at the same object (or square). It is used as a base case for all possible paths in the graph structure.
* `'x isaset`: This type represents an assignment of paths between two objects (or squares), where each object can have multiple paths connecting to it. The paths are represented by other types, and the object belongs to a specific level in the hierarchy (`isofhlevel`).
* `cgraph`: This type represents a graph structure where each object (or square) has a unique identifier (`coq_UU`) and can be connected to other objects with lines of different shapes and thicknesses. The hierarchy of objects is represented by the `isofhlevel` type, and the paths between objects are represented by the `'a paths` type.
* `arc -> node paths`: This type represents a function that takes an arc (or connection) and returns a path between two objects connected by that arc. The path can have different shapes and thicknesses, represented by other types.
* `arc -> node paths`: This type represents a function that takes an arc (or connection) and returns a path between two objects connected by that arc. The path can have different shapes and thicknesses, represented by other types.
#+end_src


*
*shell*<2>

test2.ml:91:and rec_flag = Asttypes.rec_flag = Nonrecursive | Recursive
*
let process_rec_flag ( x:rec_flag):string="process_rec_flag" ^
                                          match x with 
                                          | Nonrecursive -> "plain"
                                          | Recursive -> "rec"

[print_type_decl:"rec_flag" = type variant:constructor:"Nonrecursive"{Pcstr_tuple:my_process_core_type_list:}	|constructor:"Recursive"{Pcstr_tuple:my_process_core_type_list:}	|VARIANT(rec_flag)

*** fixmes:

DBG22A:let process_rec_flag"-> x : rec_flag"->= x

DBG22E:constructor_declaration_new: constructor:"Pstr_type"{| Pstr_type (rec_flag"->0,list"->type_declaration"->00) -> (process_types_structure_item_desc__Pstr_type((process_rec_flag"-> rec_flag"->0),(process_list"->type_declaration"->0 list"->type_declaration"->01)))}

let process_types_rec_flag__Nonrecursive(():()):string = (process_types ^ ("rec_flag","Nonrecursive") ^)
let process_types_rec_flag__Recursive(():()):string = (process_types ^ ("rec_flag","Recursive") ^)

let process_rec_flag__Recursive x :string =match x with
| Recursive () -> (process_types_rec_flag__Recursive())
| Nonrecursive () -> (process_types_rec_flag__Nonrecursive())


*** handle a list of items

*** generate v7
grep -e "DBG221EC" -e "DBG222EC" test/test2.txt  |cut -d: -f2- > ./src/gen7.ml


* Counts of Pexp
      6 "Pexp_apply
      7 "Pexp_tuple"
      9 "Pexp_constant"
      9 "Pexp_fun"
     18 "Pexp_construct"
     53 "Pexp_constant"
    106 "Pexp_apply"
    113 "Pexp_ident"


    grep generic_type test3/test3.txt | fold -w 40 -s | grep Ppat_ |sort |uniq -c |sort -n
      1 "pattern_desc" "Ppat_construct" [(ident 
      1 "pattern_desc" "Ppat_var"
      1 "Pconst_string" [(string "Ppat_var" 
     23 "pattern_desc" "Ppat_var" [(process_loc 

    so Ppat_construct and Ppat_var as pattern_desc


    grep generic_type test3/test3.txt | fold -w 40 -s | grep Pstr_ |sort |uniq -c |sort -n
      1 "Pconst_string" [(string "Pstr_value" 
      1 "Pstr_value" [(process_generic_type 
      1 "structure_item_desc" "Pstr_value"
     12 "structure_item_desc" "Pstr_value" 

     so  "Pstr_value" only


     and the const values


           1 "Pconst_integer" [(string "10" 
      1 "Pconst_string" [(string "1" 
      1 "Pconst_string" [(string "attributes" 
      1 "Pconst_string" [(string "constant" 
      1 "Pconst_string" [(string "foo" 
      1 "Pconst_string" [(string "Nonrecursive" 
      1 "Pconst_string" [(string "pattern_desc" 
      1 "Pconst_string" [(string "Ppat_var" 
      1 "Pconst_string" [(string "Pstr_value" 
      1 "Pconst_string" [(string "rec_flag" 
      2 "Pconst_integer" [(string "4" 
      2 "Pconst_integer" [(string "7" 
      3 "Pconst_integer" [(string "11" 
      6 "Pconst_string" [(string "process_loc" 
     10 "Pconst_integer" [(string "1" 
     12 "Pconst_integer" [(string "0" 
     18 "Pconst_string" [(string
     

*counts from strings from 4

grep generic_type test4.ml | fold -w 60 -s | grep Pconst_string |sort |uniq -c |sort -n


      1 "constant" "Pconst_string" [(string "attributes" 
      1 "constant" "Pconst_string" [(string "ident" 
      1 "constant" "Pconst_string" [(string "Ppat_construct" 
      1 "constant" "Pconst_string" [(string "process_generic_type" 
      2 "constant" "Pconst_string" [(string "process_string" 
      6 "constant" "Pconst_string" [(string "process_loc" 
      7 "constant" "Pconst_string" [(string "Pexp_tuple" 
      8 "constant" "Pconst_string" [(string 
     11 "constant" "Pconst_string" [(string "Pexp_fun" 
     13 "constant" "Pconst_string" [(string "Nonrecursive" 
     13 "constant" "Pconst_string" [(string "Pstr_value" 
     19 "constant" "Pconst_string" [(string "Pexp_construct" 
     23 "constant" "Pconst_string" [(string "Ppat_var" 
     30 "constant" "Pconst_string" [(string "Pconst_integer" 
     34 "constant" "Pconst_string" [(string "Pconst_string" 
     64 "constant" "Pconst_string" [(string "Pexp_constant" 
    122 "constant" "Pconst_string" [(string "Pexp_apply" 
    127 "constant" "Pconst_string" [(string "Pexp_ident" 
    194 "constant" "Pconst_string" [(string "Nolabel" 
   1852 [(process_generic_type "constant" "Pconst_string" [(string 

   * next steps:
     finalize compilable output from gen7 and then write drivers to emit unimath theorems about the types found.
     
* overview

generate and test the code .
first we build the ppx,
then the extraction from the unimath core
then we compile that and extract it again, but that breaks the compiler.
#+begin_src shell
  dune build
  make test/unimathcore.txt -B
  grep foo1 test/unimathcore.txt >> test/unimathcore_refl.ml

  dune build
#+end_src

*** unimath extract

we are working on extracting now to unimath here.
dune exec test/unimathcore_refl2.exe


***json

here are some processing of the json

   dune exec test/unimathcore_refl2.exe > test.json
   gron -s test.json | cut -d[ -f3-   | sort |uniq -c |sort -n
   gron -s test.json | cut -d= -f2-   | sort |uniq -c |sort -n
  
gron -s test.json | cut -d= -f2-   | sort |uniq -c |sort -n

 2  "foo1";
      2  "loc2";
      2  "loc_stack";
      2  "none";
      3  " none ";
      4  "Pexp_constraint";
      4  "Pstr_type";
      4  "structure_item_desc";
      4  "y";
      5  "b";
      6  "c";
      6  "list";
      6  "process_arg_constructor_declaration";
      6  "process_expression_list";
      6  "process_label_declaration_list";
      6  "process_loc";
      6  "process_string_loc_list_pattern_option";
      6  "process_vars_list";
      7  "process_arg_label_expression";
      7  "process_structure_items";
      7  "Recursive";
      9  "Ppat_constraint";
     10  "a";
     11  "loc";
     13  "__";
     14  "process_type_declaration_list";
     16  "Ptype_abstract";
     16  "type_kind";
     17  "private_flag";
     17  "Public";
     19  "Nonrecursive";
     19  "process_params";
     20  "Obj.t";
     20  "process_cstrs";
     21  "Pexp_fun";
     25  "ident";
     26  "rec_flag";
     27  "process_core_type_list";
     28  "Ad_list";
     34  "string";
     37  "x";
     40  "core_type_desc";
     40  "Ptyp_constr";
     50  "::";
     50  "Pexp_tuple";
     55  "Ad_arg_label_expression_list";
     60  "Ppat_var";
     65  "process_generic_type";
     69  "^";
     69  "pattern_desc";
    122  "[]";
    158  "Pexp_construct";
    160  "Ad_None";
    168  "Pexp_constant";
    178  "Pexp_apply";
    195  "Ad_process_arg_label_expression_list";
    198  "constant";
    198  "Pconst_string";
    198  "Pexp_ident";
    228  "Ad_NoString";
    324  "Ad_String";
    360  "Ad_process_arg_label_expression";
    398  "arg_label";
    398  "Nolabel";
    416  "Ad_Ident";
    777  "expression_desc";
   1484  {};
   1484  "Ad_root";
   5277  [];


 ** backtrace

 OCAMLRUNPARAM=b dune exec test/unimathcore_refl2.exe

** example output of new debug
 #+begin_src input
rewrite and reinterpret creatively preserving main ideas """(rec_root rec_flag^Nonrecursive^)^(rec_root pattern_desc^Ppat_var^(Ad_String "foo1"))^(rec_root expression_desc^Pexp_apply^(rec_root expression_desc^Pexp_ident^(Ad_Ident "process_generic_type)")^(process_generic_type3 ast_desc^Ad_process_arg_label_expression_list[[]]))"""
#+end_src
#+begin_src output

Original:
```css
(rec_root rec_flag^Nonrecursive^)^(rec_root pattern_desc^Ppat_var^(Ad_String "foo1"))^(rec_root expression_desc^Pexp_apply^(rec_root expression_desc^Pexp_ident^(Ad_Ident "process_generic_type)")^(process_generic_type3 ast_desc^Ad_process_arg_label_expression_list[[]]))
```

Rewritten:
```css
Let's start with a non-recursive root that contains a pattern description for "foo1". Then, we have an expression root that applies a function to another expression root. The function being applied is the process generic type, which takes one argument: an expression root that identifies "process\_generic\_type". This expression root has no arguments and returns nothing. However, it is used in the application of the process generic type function, which takes a list of arguments consisting of a single expression root that does not have any arguments but applies another expression root to itself.
```

Interpreted creatively:
Imagine a puzzle where we have three pieces of information: a non-recursive pattern for "foo1", an expression that applies a function to another expression, and a function that takes one argument and returns nothing. Now, let's put these pieces together like a jigsaw puzzle. We start with the non-recursive pattern for "foo1", which is like the first piece of information we have. Then, we apply a function to this pattern, which is like the second piece of information. This function takes one argument, which is an expression root that identifies "process\_generic\_type". The process generic type function does not return anything, so it's like the third piece of information, but it's not the final puzzle. To complete the puzzle, we have to put this last piece together with the other two pieces. We do this by applying the process generic type function to a list of arguments consisting of a single expression root that does not have any arguments but applies another expression root to itself.
#+end_src
